{"ast":null,"code":"'use strict';\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nvar DELIMITER = '.';\n/**\r\n * Determine whether a path argument is valid\r\n * @param path\r\n * @return {boolean}\r\n */\n\nfunction isValidPath(path) {\n  if (path === null || path === undefined) return false;\n  return typeof path === 'string' && path.length > 0;\n}\n/**\r\n * Private constructor. Use <code>Maybe.of()</code> instead.\r\n * @param val {*} Object, string, or number\r\n * @constructor\r\n */\n\n\nvar Maybe = function Maybe(val) {\n  this.__value = val;\n};\n/**\r\n * Public constructor. Creates an instance of Maybe.\r\n * @param val {*} Object, string, number, or function (direct object access)\r\n * @example const exampleObj = {\r\n *      foo: 'bar',\r\n *      baz: [1,2,3]\r\n * };\r\n *\r\n * const maybe1 = Maybe.of(exampleObj);\r\n * const maybe2 = Maybe.of(() => exampleObj.baz.1);\r\n * @returns {Maybe} A Maybe monad\r\n */\n\n\nMaybe.of = function (val) {\n  try {\n    return new Maybe(typeof val === 'function' ? val() : val);\n  } catch (error) {\n    return new Maybe(undefined);\n  }\n};\n/**\r\n * Get the monad's value\r\n * @example const maybe1 = Maybe.of(123);\r\n * const maybe2 = Maybe.of(null);\r\n *\r\n * maybe1.join();   // 123\r\n * maybe2.join();   // null\r\n * @returns {*} Returns the value of the monad\r\n */\n\n\nMaybe.prototype.join = function () {\n  return this.__value;\n};\n/**\r\n * Determine whether the monad's value exists\r\n * @example const maybe1 = Maybe.of(123);\r\n * const maybe2 = Maybe.of(undefined);\r\n *\r\n * maybe1.isJust();    // true\r\n * maybe2.isJust();    // false\r\n * @returns {boolean} <code>true</code> if the value is defined,\r\n * <code>false</code> if the monad is null or undefined.\r\n */\n\n\nMaybe.prototype.isJust = function () {\n  return !this.isNothing();\n};\n/**\r\n * Determine whether the monad's value is null or undefined\r\n * @example const maybe1 = Maybe.of(null);\r\n * const maybe2 = Maybe.of(123);\r\n *\r\n * maybe1.isNothing();    // true\r\n * maybe2.isNothing()     // false\r\n * @returns {boolean} <code>true</code> if the value is null or\r\n * undefined, <code>false</code> if the value is defined.\r\n */\n\n\nMaybe.prototype.isNothing = function () {\n  return this.__value === null || this.__value === undefined;\n};\n/**\r\n * Chain to the end of <code>prop</code>, <code>props</code>, or <code>path</code> as the\r\n * default value to return if the <code>isNothing()</code> is true\r\n * @param defaultValue {string} Return this value when\r\n * <code>join()</code> is called and <code>isNothing()</code> is true\r\n * @example const maybe1 = Maybe.of(null);\r\n *\r\n * maybe1.orElse('N/A');\r\n * maybe1.join();   // 'N/A'\r\n * @returns {Maybe} A monad containing the default value\r\n */\n\n\nMaybe.prototype.orElse = function (defaultValue) {\n  if (this.isNothing()) {\n    return Maybe.of(defaultValue);\n  }\n\n  return this;\n};\n/**\r\n * Get a value on the monad given a single property\r\n * @param property {string|number} Look for this property on the monad\r\n * @example const exampleObj = {\r\n *      foo: 'bar',\r\n *      baz: [1,2,3]\r\n * };\r\n *\r\n * const maybeBar = Maybe.of(exampleObj).prop('foo');\r\n *\r\n * maybeBar.join();     // 'bar'\r\n * @returns {Maybe} A monad containing the value of a given property or index\r\n */\n\n\nMaybe.prototype.prop = function (property) {\n  return this.map(function (value) {\n    return value[property];\n  });\n};\n/**\r\n * Get a value on the monad given a property path in argument form\r\n * @param properties {string|number} Argument list that represents the property path to search\r\n * @example const exampleObj = {\r\n *      foo: 'bar',\r\n *      baz: [1,2,3]\r\n * };\r\n *\r\n * const maybeArrayVal = Maybe.of(exampleObj).props('baz', 0);\r\n *\r\n * maybeArrayVal.join();     // 1\r\n * @returns {Maybe} A monad containing the value at a given path\r\n */\n\n\nMaybe.prototype.props = function () {\n  for (var _len = arguments.length, properties = Array(_len), _key = 0; _key < _len; _key++) {\n    properties[_key] = arguments[_key];\n  }\n\n  if (properties.length === 0) {\n    return Maybe.of(undefined);\n  }\n\n  var maybeValue = this.prop(properties.shift());\n  return properties.length > 0 ? maybeValue.props.apply(maybeValue, properties) : maybeValue;\n};\n/**\r\n * Get a value on the monad given a property path in string form\r\n * @param path {string} A period delimited string representing the path (e.g. 'foo.bar.baz)\r\n * to search\r\n * @example const exampleObj = {\r\n *      foo: 'bar',\r\n *      baz: [1,2,3]\r\n * };\r\n *\r\n * const maybeArrayVal = Maybe.of(exampleObj).path('baz.0');\r\n *\r\n * maybeArrayVal.join();     // 1\r\n * @returns {Maybe} A monad containing the value at a given path\r\n */\n\n\nMaybe.prototype.path = function (path) {\n  return isValidPath(path) ? this.props.apply(this, _toConsumableArray(path.split(DELIMITER))) : Maybe.of(undefined);\n};\n/**\r\n * Apply a transformation to the monad\r\n * @param transform {function} The transformation function to apply to the monad\r\n * @example Maybe.of(1).map(val => val + 1);\r\n * @returns {Maybe} A monad created from the result of the transformation\r\n */\n\n\nMaybe.prototype.map = function (transform) {\n  if (typeof transform !== 'function') throw new Error('transform must be a function');\n\n  if (this.isNothing()) {\n    return Maybe.of(undefined);\n  }\n\n  return Maybe.of(transform(this.join()));\n};\n/**\r\n * Chain together functions that return Maybe monads\r\n * @param fn {function} Function that is passed the value of the calling monad, and returns a monad.\r\n * @example function addOne (val) {\r\n *   return Maybe.of(val + 1);\r\n * }\r\n *\r\n * const three = Maybe.of(1)\r\n *  .chain(addOne)\r\n *  .chain(addOne)\r\n *  .join();\r\n * @returns {Maybe} A monad created from the result of the transformation\r\n */\n\n\nMaybe.prototype.chain = function (fn) {\n  return this.map(fn).join();\n};\n\nmodule.exports = Maybe;","map":null,"metadata":{},"sourceType":"script"}